import ch.qos.logback.classic.Level
import ch.qos.logback.classic.Logger
import ch.qos.logback.classic.LoggerContext
import ch.qos.logback.core.read.ListAppender
import com.fasterxml.jackson.databind.ObjectMapper
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.slf4j.LoggerFactory
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class MyLoggerTest {

    private lateinit var logger: Logger
    private lateinit var listAppender: ListAppender<*>

    @BeforeEach
    fun setUp() {
        // Initialize the logger and list appender
        val loggerContext = LoggerFactory.getILoggerFactory() as LoggerContext
        logger = loggerContext.getLogger(MyLoggerTest::class.java) as Logger
        listAppender = ListAppender<Any>()
        listAppender.start()
        logger.addAppender(listAppender)
    }

    @AfterEach
    fun tearDown() {
        // Reset logger and detach the list appender
        logger.detachAppender(listAppender)
    }

    @Test
    fun `test logStatus`() {
        // Arrange
        val logMessage = "This is a test log message"
        val logKafkaMessage = LogKafkaMessage()
        logKafkaMessage.key = "APPLICATION_NAME_SHURC"
        logKafkaMessage.message = logMessage
        logKafkaMessage.applicationName = "APPLICATION_NAME"

        // Act
        try {
            logger.debug(ObjectMapper().writeValueAsString(logKafkaMessage))
        } catch (e: JsonProcessingException) {
            throw RuntimeException(e)
        }

        // Assert
        // Capture log output
        val logList = listAppender.list
        val capturedLogMessage = logList[0].formattedMessage

        // Verify log output
        assertTrue(logList.isNotEmpty())
        assertEquals(Level.DEBUG, logList[0].level)
        assertTrue(capturedLogMessage.contains(logMessage))
    }
}
